<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Star Wars TD - Ultimate Attack Edition</title>
<style>
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  #game-container {
    display: flex;
    gap: 20px;
    margin-top: 20px;
    position: relative;
  }
  canvas {
    background-color: #111;
    border: 2px solid #fff;
    image-rendering: pixelated;
    cursor: crosshair;
  }
  #battleCanvas {
    width: 800px;
    height: 500px;
  }
  #uiPanel {
    width: 340px;
    background: #111;
    padding: 10px;
    border: 2px solid #fff;
    border-radius: 8px;
    position: relative;
  }
  button {
    width: 100%;
    margin: 5px 0;
    padding: 10px;
    font-weight: bold;
    background: #222;
    color: #fff;
    border: 1px solid #666;
    border-radius: 5px;
    cursor: pointer;
  }
  button:hover:not(:disabled) {
    background: #444;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  #towerInfo {
    margin-top: 10px;
    background: #000;
    padding: 10px;
    border-radius: 6px;
    min-height: 200px;
  }
  h2 {
    margin-top: 0;
  }
  .upgrade-button, .special-button, #ultimateButton {
    margin: 5px 0;
    padding: 6px;
    font-size: 0.9em;
    background: #333;
    border: 1px solid #555;
    cursor: pointer;
    border-radius: 4px;
  }
  .upgrade-button:disabled, .special-button:disabled, #ultimateButton:disabled {
    background: #555;
    cursor: not-allowed;
  }
  #specialCooldown {
    margin-top: 10px;
    font-weight: bold;
    text-align: center;
  }
  #waveControls {
    margin-top: 10px;
  }
  #placementPreview {
    position: absolute;
    pointer-events: none;
    border: 2px dashed yellow;
    border-radius: 50%;
    opacity: 0.5;
  }
  /* Ultimate selection overlay */
  #ultimateSelectionOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(0,0,0,0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    color: white;
  }
  #ultimateSelectionOverlay h2 {
    margin-bottom: 15px;
  }
  #ultimateTowersContainer {
    display: flex;
    gap: 15px;
  }
  .ultimateTowerChoice {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    cursor: pointer;
    border: 3px solid transparent;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.9em;
    user-select: none;
  }
  .ultimateTowerChoice:hover {
    border-color: yellow;
  }
  .ultimateTowerChoice.selected {
    border-color: limegreen;
    box-shadow: 0 0 10px limegreen;
  }
  #killsCounter {
    margin-top: 10px;
    font-weight: bold;
    text-align: center;
    font-size: 1.2em;
  }
  /* Ultimate animation ring */
  .ultimate-ring {
    position: absolute;
    pointer-events: none;
    border: 4px solid cyan;
    border-radius: 50%;
    opacity: 0.8;
    animation: pulseRing 1.5s infinite ease-in-out;
  }
  @keyframes pulseRing {
    0% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.3); opacity: 0.3; }
    100% { transform: scale(1); opacity: 0.8; }
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet" />
</head>
<body>

<h1>Star Wars Tower Defense - Ultimate Attack Edition</h1>

<div id="game-container">
  <canvas id="battleCanvas" width="800" height="500"></canvas>

  <div id="uiPanel">
    <h2>Tower Shop</h2>
    <button id="btnStormtrooper">Stormtrooper Tower (Free)</button>
    <button id="btnLuke">Luke Skywalker Tower (200 credits)</button>
    <button id="btnDarth">Darth Vader Tower (300 credits)</button>

    <p><strong>Credits:</strong> <span id="credits">500</span></p>
    <p><strong>Base Health:</strong> <span id="baseHealth">10</span></p>

    <div id="waveControls">
      <button id="btnStartWave" disabled>Start Next Wave</button>
      <p>Wave: <span id="waveNumber">1</span></p>
    </div>

    <div id="towerInfo">
      <h3>Tower Info</h3>
      <div id="towerDetails">Select a tower to see details here.</div>
      <div id="killsCounter"></div>
      <div id="specialCooldown"></div>
      <div id="upgradeSection" style="display:none;">
        <h4>Upgrade Paths</h4>
        <div id="upgrades"></div>
      </div>
      <div id="specialSection" style="display:none;">
        <button id="specialButton" class="special-button">Use Special Attack</button>
      </div>
      <div id="ultimateSection" style="display:none;">
        <button id="ultimateButton" class="special-button">Use Ultimate Attack</button>
      </div>
    </div>
  </div>
</div>

<!-- Ultimate Selection Overlay -->
<div id="ultimateSelectionOverlay">
  <h2>Select Your Ultimate Tower</h2>
  <div id="ultimateTowersContainer">
    <!-- Towers will be populated here dynamically -->
  </div>
  <button id="confirmUltimate" disabled>Confirm Ultimate Tower</button>
</div>

<script>
// --- Game Variables ---
const canvas = document.getElementById('battleCanvas');
const ctx = canvas.getContext('2d');
const creditsDisplay = document.getElementById('credits');
const towerDetails = document.getElementById('towerDetails');
const upgradeSection = document.getElementById('upgradeSection');
const upgradesDiv = document.getElementById('upgrades');
const specialCooldownDisplay = document.getElementById('specialCooldown');
const baseHealthDisplay = document.getElementById('baseHealth');
const waveNumberDisplay = document.getElementById('waveNumber');
const btnStartWave = document.getElementById('btnStartWave');
const specialButton = document.getElementById('specialButton');
const specialSection = document.getElementById('specialSection');
const killsCounter = document.getElementById('killsCounter');
const ultimateSection = document.getElementById('ultimateSection');
const ultimateButton = document.getElementById('ultimateButton');
const ultimateSelectionOverlay = document.getElementById('ultimateSelectionOverlay');
const ultimateTowersContainer = document.getElementById('ultimateTowersContainer');
const confirmUltimateBtn = document.getElementById('confirmUltimate');

let credits = 500;
let baseHealth = 10;
let waveNumber = 1;
let towers = [];
let enemies = [];
let selectedTower = null;
let enemySpawnTimer = 0;
let enemiesToSpawn = 0;
let spawningWave = false;
let path = [];

let placementPreview = null;
let placingTowerType = null;

let ultimateTower = null; // The tower chosen for ultimate
const ULTIMATE_KILLS_REQUIRED = 50;

// For ultimate animation
let ultimateAnimationStart = 0;
let ultimateAnimationDuration = 3000; // 3 seconds
let ultimateAnimating = false;

// --- Define Path for enemies ---
function definePath() {
  path = [
    {x: 0, y: 250},
    {x: 200, y: 250},
    {x: 200, y: 400},
    {x: 600, y: 400},
    {x: 600, y: 100},
    {x: 800, y: 100}
  ];
}

// --- Tower Class ---
class Tower {
  constructor(name, x, y, cost, color) {
    this.name = name;
    this.x = x;
    this.y = y;
    this.cost = cost;
    this.color = color; // lightsaber color or white for stormtrooper
    this.range = 120;
    this.fireRate = 1000; // ms
    this.damage = 10;
    this.lastShot = 0;

    this.specialCooldown = 10000; // 10 seconds cooldown
    this.lastSpecial = 0;

    this.upgradePaths = {
      damage: 0,
      range: 0,
      fireRate: 0,
    };

    this.kills = 0;
  }

  draw() {
    // Draw tower circle with lightsaber color
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
    ctx.fill();

    // Highlight if selected
    if (selectedTower === this) {
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  canShoot() {
    return Date.now() - this.lastShot >= this.fireRate;
  }

  shoot(enemy) {
    enemy.health -= this.damage;
    this.lastShot = Date.now();
    playShootSound();
    if(enemy.health <= 0) {
      this.kills++;
      if(this === ultimateTower) updateKillsCounter();
    }
  }

  isEnemyInRange(enemy) {
    const dx = enemy.x - this.x;
    const dy = enemy.y - this.y;
    return Math.sqrt(dx*dx + dy*dy) <= this.range;
  }

  canUseSpecial() {
    return Date.now() - this.lastSpecial >= this.specialCooldown;
  }

  useSpecial() {
    if (!this.canUseSpecial()) return false;
    this.lastSpecial = Date.now();

    // Special effects depending on tower name
    if(this.name === 'Stormtrooper Tower') {
      enemies.forEach(enemy => {
        if(this.isEnemyInRange(enemy)) {
          enemy.health -= this.damage * 3;
          if(enemy.health <= 0) this.kills++;
        }
      });
    } else if(this.name === 'Luke Skywalker Tower') {
      let hitCount = 0;
      for(let enemy of enemies) {
        if(this.isEnemyInRange(enemy)) {
          enemy.health -= this.damage * 5;
          if(enemy.health <= 0) this.kills++;
          hitCount++;
          if(hitCount >= 3) break;
        }
      }
    } else if(this.name === 'Darth Vader Tower') {
      enemies.forEach(enemy => {
        if(this.isEnemyInRange(enemy)) {
          enemy.health -= this.damage * 4;
          if(enemy.health <= 0) this.kills++;
          enemy.currentPoint = Math.max(0, enemy.currentPoint - 1);
          const pos = enemy.path[enemy.currentPoint];
          enemy.x = pos.x;
          enemy.y = pos.y;
        }
      });
    }
    if(this === ultimateTower) updateKillsCounter();

    playSpecialSound();
    if(selectedTower === this) updateSpecialCooldown(this);
    return true;
  }

  getSpecialCooldownRemaining() {
    const remaining = this.specialCooldown - (Date.now() - this.lastSpecial);
    return remaining > 0 ? remaining : 0;
  }

  upgrade(path) {
    if (this.upgradePaths[path] < 3) {
      const cost = 100 * (this.upgradePaths[path] + 1);
      if (credits >= cost) {
        credits -= cost;
        this.upgradePaths[path]++;
        switch(path) {
          case 'damage': this.damage += 5; break;
          case 'range': this.range += 20; break;
          case 'fireRate': this.fireRate = Math.max(300, this.fireRate - 200); break;
        }
        updateCredits();
        updateTowerInfo(this);
        updateUpgradeButtons();
      } else {
        alert('Not enough credits to upgrade!');
      }
    }
  }

  canUseUltimate() {
    return this.kills >= ULTIMATE_KILLS_REQUIRED && !ultimateAnimating;
  }

  useUltimate() {
    if (!this.canUseUltimate()) return false;

    ultimateAnimating = true;
    ultimateAnimationStart = Date.now();

    // Ultimate effect: big damage to all enemies in range, big flashy animation
    enemies.forEach(enemy => {
      if(this.isEnemyInRange(enemy)) {
        enemy.health -= this.damage * 20;
      }
    });

    this.kills = 0;
    updateKillsCounter();
    playUltimateSound();

    // Disable ultimate button during animation
    if(selectedTower === this) updateUltimateButton();

    // After animation duration, end ultimate animation flag
    setTimeout(() => {
      ultimateAnimating = false;
      if(selectedTower === this) updateUltimateButton();
    }, ultimateAnimationDuration);

    return true;
  }
}

// --- Enemy Class ---
class Enemy {
  constructor(path, type='basic') {
    this.path = path;
    this.currentPoint = 0;
    this.x = path[0].x;
    this.y = path[0].y;
    this.type = type;
    this.radius = 15;

    if(type === 'fast') {
      this.speed = 2.5;
      this.health = 20 + waveNumber * 8;
    } else {
      this.speed = 1.5;
      this.health = 30 + waveNumber * 10;
    }
    this.maxHealth = this.health;
  }

  move() {
    if(this.currentPoint >= this.path.length - 1) return;

    const target = this.path[this.currentPoint + 1];
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if(dist < this.speed) {
      this.x = target.x;
      this.y = target.y;
      this.currentPoint++;
    } else {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
  }

  draw() {
    // Draw enemy circle
    ctx.fillStyle = this.type === 'fast' ? 'orange' : 'red';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();

    // Health bar
    ctx.fillStyle = 'black';
    ctx.fillRect(this.x - 20, this.y - 25, 40, 6);
    ctx.fillStyle = 'lime';
    ctx.fillRect(this.x - 20, this.y - 25, 40 * (this.health / this.maxHealth), 6);
    ctx.strokeStyle = 'white';
    ctx.strokeRect(this.x - 20, this.y - 25, 40, 6);
  }
}

// --- Helper Functions ---
function updateCredits() {
  creditsDisplay.textContent = credits;
}

function updateBaseHealth() {
  baseHealthDisplay.textContent = baseHealth;
}

function updateWaveNumber() {
  waveNumberDisplay.textContent = waveNumber;
}

function updateTowerInfo(tower) {
  selectedTower = tower;
  upgradeSection.style.display = 'block';
  specialSection.style.display = 'block';

  towerDetails.innerHTML = `
    <p><strong>Name:</strong> ${tower.name}</p>
    <p><strong>Damage:</strong> ${tower.damage}</p>
    <p><strong>Range:</strong> ${tower.range}</p>
    <p><strong>Fire Rate (ms):</strong> ${tower.fireRate}</p>
  `;

  updateSpecialCooldown(tower);
  updateUpgradeButtons();

  if(tower === ultimateTower) {
    ultimateSection.style.display = 'block';
    updateKillsCounter();
    updateUltimateButton();
  } else {
    ultimateSection.style.display = 'none';
    killsCounter.textContent = '';
  }
}

function updateKillsCounter() {
  if(ultimateTower) {
    killsCounter.textContent = `Kills: ${ultimateTower.kills}/${ULTIMATE_KILLS_REQUIRED}`;
  } else {
    killsCounter.textContent = '';
  }
}

function updateSpecialCooldown(tower) {
  if(!tower) {
    specialCooldownDisplay.textContent = '';
    return;
  }

  let remaining = tower.getSpecialCooldownRemaining();
  if(remaining > 0) {
    specialCooldownDisplay.textContent = `Special attack ready in ${(remaining/1000).toFixed(1)} seconds`;
  } else {
    specialCooldownDisplay.textContent = `Special attack READY!`;
  }
}

function updateUpgradeButtons() {
  upgradesDiv.innerHTML = '';
  if (!selectedTower) return;

  createUpgradeButton('damage', 'Increase Damage', selectedTower.upgradePaths.damage);
  createUpgradeButton('range', 'Increase Range', selectedTower.upgradePaths.range);
  createUpgradeButton('fireRate', 'Increase Fire Rate', selectedTower.upgradePaths.fireRate);
}

function createUpgradeButton(path, label, level) {
  const btn = document.createElement('button');
  btn.textContent = `${label} (Level ${level}/3) - Cost: ${100*(level+1)} credits`;
  btn.className = 'upgrade-button';
  if(level >= 3) {
    btn.disabled = true;
    btn.textContent = `${label} (MAX)`;
  }
  btn.onclick = () => {
    if(selectedTower) selectedTower.upgrade(path);
  }
  upgradesDiv.appendChild(btn);
}

function updateUltimateButton() {
  if(!ultimateTower || selectedTower !== ultimateTower) {
    ultimateButton.disabled = true;
    ultimateButton.textContent = "Use Ultimate Attack";
    return;
  }
  if(ultimateTower.canUseUltimate()) {
    ultimateButton.disabled = false;
    ultimateButton.textContent = "Use Ultimate Attack!";
  } else {
    ultimateButton.disabled = true;
    ultimateButton.textContent = `Kills ${ultimateTower.kills}/${ULTIMATE_KILLS_REQUIRED}`;
  }
}

// --- Tower Placement ---
function placeTower(towerType, position) {
  // Check if space is free (not too close to other towers)
  for(let tower of towers) {
    const dx = tower.x - position.x;
    const dy = tower.y - position.y;
    if(Math.sqrt(dx*dx + dy*dy) < 60) {
      alert("Too close to another tower!");
      return false;
    }
  }
  if(towerType.cost > credits) {
    alert("You don't have enough credits!");
    return false;
  }
  credits -= towerType.cost;
  updateCredits();

  const newTower = new Tower(towerType.name, position.x, position.y, towerType.cost, towerType.color);
  towers.push(newTower);
  updateTowerInfo(newTower);
  return true;
}

// --- Spawn Enemy ---
function spawnEnemy() {
  const enemyType = Math.random() < 0.3 ? 'fast' : 'basic';
  enemies.push(new Enemy(path, enemyType));
}

// --- Sound Effects ---
function playShootSound() {
  // Simple beep
  const ctxAudio = new AudioContext();
  const osc = ctxAudio.createOscillator();
  osc.frequency.value = 600;
  osc.connect(ctxAudio.destination);
  osc.start();
  osc.stop(ctxAudio.currentTime + 0.05);
}
function playSpecialSound() {
  const ctxAudio = new AudioContext();
  const osc = ctxAudio.createOscillator();
  osc.frequency.value = 300;
  osc.connect(ctxAudio.destination);
  osc.start();
  osc.stop(ctxAudio.currentTime + 0.1);
}
function playUltimateSound() {
  const ctxAudio = new AudioContext();
  const osc = ctxAudio.createOscillator();
  osc.frequency.value = 900;
  osc.connect(ctxAudio.destination);
  osc.start();
  osc.stop(ctxAudio.currentTime + 0.3);
}

// --- Game Loop ---
function gameLoop() {
  if(!gameRunning) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw path line
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for(let i=1; i<path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();

  // Draw towers
  for(let tower of towers) {
    tower.draw();
  }

  // Draw enemies and move them
  for(let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    enemy.move();
    enemy.draw();

    if(enemy.health <= 0) {
      enemies.splice(i, 1);
      credits += 20;
      updateCredits();
    } else if(enemy.currentPoint >= path.length - 1) {
      enemies.splice(i, 1);
      baseHealth--;
      updateBaseHealth();
      if(baseHealth <= 0) {
        gameRunning = false;
        alert("Game Over! Your base has been destroyed.");
      }
    }
  }

  // Towers shoot enemies and use special attacks
  for(let tower of towers) {
    if(!ultimateAnimating) {
      if(tower.canUseSpecial()) {
        // Don't auto-use special if ultimateAnimating, to keep things clear
      }

      if(tower.canShoot()) {
        let target = enemies.find(e => tower.isEnemyInRange(e));
        if(target) {
          tower.shoot(target);
          // Draw laser line
          ctx.strokeStyle = 'yellow';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(tower.x, tower.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
        }
      }
    }
  }

  // Draw ultimate animation ring if active
  if(ultimateAnimating && ultimateTower) {
    const elapsed = Date.now() - ultimateAnimationStart;
    if(elapsed < ultimateAnimationDuration) {
      const scale = 1 + 0.3 * Math.sin((elapsed / ultimateAnimationDuration) * Math.PI * 4);
      const alpha = 0.8 * (1 - elapsed / ultimateAnimationDuration);

      ctx.save();
      ctx.strokeStyle = `rgba(0, 255, 255, ${alpha.toFixed(2)})`;
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(ultimateTower.x, ultimateTower.y, 40 * scale, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  // Update cooldown display for selected tower
  if(selectedTower) {
    updateSpecialCooldown(selectedTower);
    updateKillsCounter();
    updateUltimateButton();
  }

  // Spawn enemies per wave
  if(spawningWave && enemiesToSpawn > 0) {
    if(enemySpawnTimer > 300) {
      spawnEnemy();
      enemiesToSpawn--;
      enemySpawnTimer = 0;
    }
    enemySpawnTimer += 16;
  } else if(spawningWave && enemiesToSpawn === 0 && enemies.length === 0) {
    spawningWave = false;
    waveNumber++;
    updateWaveNumber();
    alert(`Wave ${waveNumber - 1} finished! Prepare for wave ${waveNumber}`);
    btnStartWave.disabled = false;
  }

  requestAnimationFrame(gameLoop);
}

let gameRunning = true;

// --- Event Listeners ---

// Tower buttons: start tower placement mode
document.getElementById('btnStormtrooper').onclick = () => startPlacingTower({name:'Stormtrooper Tower', cost:0, color:'white', range:120});
document.getElementById('btnLuke').onclick = () => startPlacingTower({name:'Luke Skywalker Tower', cost:200, color:'limegreen', range:120});
document.getElementById('btnDarth').onclick = () => startPlacingTower({name:'Darth Vader Tower', cost:300, color:'red', range:120});

// Start wave button
btnStartWave.onclick = () => {
  if(spawningWave) return;
  spawningWave = true;
  enemiesToSpawn = waveNumber * 5;
  btnStartWave.disabled = true;
}

// Canvas click: place tower or select tower
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  if(placingTowerType) {
    // Try placing tower at preview location
    if(placeTower(placingTowerType, placementPreview)) {
      placingTowerType = null;
      placementPreview = null;
      canvas.style.cursor = 'crosshair';
      btnStartWave.disabled = false; // Enable start wave after placing tower(s)
    }
    return;
  }

  // Select tower or deselect
  selectedTower = null;
  for(let tower of towers) {
    if(mouseX >= tower.x - 25 && mouseX <= tower.x + 25 &&
       mouseY >= tower.y - 25 && mouseY <= tower.y + 25) {
      selectedTower = tower;
      updateTowerInfo(tower);
      return;
    }
  }
  // If no tower selected
  towerDetails.textContent = "Select a tower to see details here.";
  upgradeSection.style.display = 'none';
  specialSection.style.display = 'none';
  ultimateSection.style.display = 'none';
  killsCounter.textContent = '';
  specialCooldownDisplay.textContent = '';
});

// Mouse move: update placement preview position if placing tower
canvas.addEventListener('mousemove', (e) => {
  if(!placingTowerType) return;
  const rect = canvas.getBoundingClientRect();
  let x = e.clientX - rect.left;
  let y = e.clientY - rect.top;

  // Clamp placement inside canvas with margin
  x = Math.min(Math.max(x, 30), canvas.width - 30);
  y = Math.min(Math.max(y, 30), canvas.height - 30);

  placementPreview = {x,y};
});

// Special attack button
specialButton.onclick = () => {
  if(selectedTower) {
    if(!selectedTower.canUseSpecial()) {
      alert('Special on cooldown!');
      return;
    }
    const used = selectedTower.useSpecial();
    if(!used) alert('Cannot use special right now.');
  }
}

// Ultimate attack button
ultimateButton.onclick = () => {
  if(selectedTower && selectedTower === ultimateTower) {
    if(!ultimateTower.canUseUltimate()) {
      alert(`Ultimate attack not ready! Kills: ${ultimateTower.kills}/${ULTIMATE_KILLS_REQUIRED}`);
      return;
    }
    const used = ultimateTower.useUltimate();
    if(!used) alert('Cannot use ultimate right now.');
  }
}

// Upgrade buttons handled inside updateUpgradeButtons()

// --- Tower placement mode ---
function startPlacingTower(towerType) {
  placingTowerType = towerType;
  placementPreview = {x: canvas.width/2, y: canvas.height/2};
  canvas.style.cursor = 'none';

  // Deselect current tower info to avoid confusion
  selectedTower = null;
  towerDetails.textContent = "Click to place your tower.";
  upgradeSection.style.display = 'none';
  specialSection.style.display = 'none';
  ultimateSection.style.display = 'none';
  killsCounter.textContent = '';
  specialCooldownDisplay.textContent = '';
  btnStartWave.disabled = true; // Disable wave start while placing towers
}

// --- Ultimate Selection Screen ---

function populateUltimateSelection() {
  // Clear container
  ultimateTowersContainer.innerHTML = '';
  // Create choices for base tower types
  const baseTowers = [
    {name:'Stormtrooper Tower', color:'white'},
    {name:'Luke Skywalker Tower', color:'limegreen'},
    {name:'Darth Vader Tower', color:'red'},
  ];

  baseTowers.forEach((towerType, idx) => {
    const div = document.createElement('div');
    div.className = 'ultimateTowerChoice';
    div.style.backgroundColor = towerType.color;
    div.textContent = towerType.name.split(' ')[0]; // short name
    div.title = towerType.name;
    div.dataset.name = towerType.name;
    div.onclick = () => {
      // Deselect all first
      Array.from(ultimateTowersContainer.children).forEach(c => c.classList.remove('selected'));
      div.classList.add('selected');
      confirmUltimateBtn.disabled = false;
    };
    ultimateTowersContainer.appendChild(div);
  });
}

confirmUltimateBtn.onclick = () => {
  const selectedDiv = ultimateTowersContainer.querySelector('.selected');
  if(!selectedDiv) return alert("Select a tower for ultimate.");

  const chosenName = selectedDiv.dataset.name;
  // We'll create an ultimateTower placeholder with 0 kills first.
  // It will link to an actual tower once you place it.
  ultimateTower = null;
  ultimateTowerTypeName = chosenName;

  // Hide overlay and enable tower placement and wave start
  ultimateSelectionOverlay.style.display = 'none';
  btnStartWave.disabled = false;

  alert(`Selected ${chosenName} as your Ultimate Tower. Place one on the battlefield!`);
}

// --- Initialize Game ---
function initGame() {
  definePath();
  updateCredits();
  updateBaseHealth();
  updateWaveNumber();
  gameLoop();

  // Show ultimate selection overlay first
  ultimateSelectionOverlay.style.display = 'flex';
  populateUltimateSelection();
  btnStartWave.disabled = true;
}

initGame();

// --- Linking ultimate tower after placement ---
// We'll assign ultimateTower to the first tower placed matching ultimateTowerTypeName
let ultimateTowerTypeName = null;

function linkUltimateTower(tower) {
  if(ultimateTower) return; // already linked
  if(tower.name === ultimateTowerTypeName) {
    ultimateTower = tower;
    updateKillsCounter();
    if(selectedTower === tower) updateTowerInfo(tower);
  }
}

// Modify placeTower to link ultimate tower
const originalPlaceTower = placeTower;
placeTower = function(towerType, position) {
  if(originalPlaceTower(towerType, position)) {
    // Link ultimate tower if matching
    linkUltimateTower(towers[towers.length - 1]);
    return true;
  }
  return false;
}

// --- Draw placement preview ---
function drawPlacementPreview() {
  if(!placingTowerType || !placementPreview) return;

  // Circle preview with tower color
  ctx.fillStyle = placingTowerType.color;
  ctx.globalAlpha = 0.3;
  ctx.beginPath();
  ctx.arc(placementPreview.x, placementPreview.y, 25, 0, Math.PI * 2);
  ctx.fill();

  // Range circle
  ctx.strokeStyle = placingTowerType.color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(placementPreview.x, placementPreview.y, placingTowerType.range, 0, Math.PI * 2);
  ctx.stroke();

  ctx.globalAlpha = 1;
}

// Integrate drawPlacementPreview in gameLoop
const oldGameLoop = gameLoop;
gameLoop = function() {
  if(!gameRunning) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw path line
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for(let i=1; i<path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();

  // Draw towers
  for(let tower of towers) {
    tower.draw();
  }

  // Draw enemies and move them
  for(let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    enemy.move();
    enemy.draw();

    if(enemy.health <= 0) {
      enemies.splice(i, 1);
      credits += 20;
      updateCredits();
    } else if(enemy.currentPoint >= path.length - 1) {
      enemies.splice(i, 1);
      baseHealth--;
      updateBaseHealth();
      if(baseHealth <= 0) {
        gameRunning = false;
        alert("Game Over! Your base has been destroyed.");
      }
    }
  }

  // Towers shoot enemies and use special attacks
  for(let tower of towers) {
    if(!ultimateAnimating) {
      if(tower.canUseSpecial()) {
        // Auto specials disabled for clarity
      }

      if(tower.canShoot()) {
        let target = enemies.find(e => tower.isEnemyInRange(e));
        if(target) {
          tower.shoot(target);
          // Draw laser line
          ctx.strokeStyle = 'yellow';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(tower.x, tower.y);
          ctx.lineTo(target.x, target.y);
          ctx.stroke();
        }
      }
    }
  }

  // Draw placement preview on top
  drawPlacementPreview();

  // Draw ultimate animation ring if active
  if(ultimateAnimating && ultimateTower) {
    const elapsed = Date.now() - ultimateAnimationStart;
    if(elapsed < ultimateAnimationDuration) {
      const scale = 1 + 0.3 * Math.sin((elapsed / ultimateAnimationDuration) * Math.PI * 4);
      const alpha = 0.8 * (1 - elapsed / ultimateAnimationDuration);

      ctx.save();
      ctx.strokeStyle = `rgba(0, 255, 255, ${alpha.toFixed(2)})`;
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.arc(ultimateTower.x, ultimateTower.y, 40 * scale, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }
  }

  // Update cooldown display for selected tower
  if(selectedTower) {
    updateSpecialCooldown(selectedTower);
    updateKillsCounter();
    updateUltimateButton();
  }

  // Spawn enemies per wave
  if(spawningWave && enemiesToSpawn > 0) {
    if(enemySpawnTimer > 300) {
      spawnEnemy();
      enemiesToSpawn--;
      enemySpawnTimer = 0;
    }
    enemySpawnTimer += 16;
  } else if(spawningWave && enemiesToSpawn === 0 && enemies.length === 0) {
    spawningWave = false;
    waveNumber++;
    updateWaveNumber();
    alert(`Wave ${waveNumber - 1} finished! Prepare for wave ${waveNumber}`);
    btnStartWave.disabled = false;
  }

  requestAnimationFrame(gameLoop);
};

</script>

</body>
</html>
